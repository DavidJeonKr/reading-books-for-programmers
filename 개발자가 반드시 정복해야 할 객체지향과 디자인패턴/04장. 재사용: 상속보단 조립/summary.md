

## 1.1 상속을 통한 재사용의 단점 1. 상위 클래스의 변경이 어려움
상위 계층을 따라 상위 클래스의 변경이 하위 클래스에 영향을 주기 때문에, 최악의 경우 상위 클래스의 변화가 모든 하위 클래스에 영향을 줄수 있다. 이는 클래스 계층도의 있는 클래스들을 한 개의 거대한 단일 구조처럼 만들어 주는 결과를 초래한다. 이런 이유 때문에, 클래스 계층도가 커질수록 상위 클래스를 변경하는 것은 점점 어려워진다.

## 1.2 상속을 통한 재사용의 단점 2. 클래스의 불필요한 증가
상송을 통한 기능 재사용의 두번째 문제점은 유사한 기능을 확장하는 과정에서 클래스의 개수가 불필요하게 중가할 수 있다는 것이다.

## 1.3 상송을 통한 재사용의 단점 3. 상속의 오용
상속을 통한 기능 재사용의 세 번째 문제점은 상속 자체를 잘못 사용할 수 있다는 점이다. 어떠한 한 개발자가 ArrayList 클래스가 제공하는 기능을 상속 받아서 사용하기로 하고 Containner 클래스라는 것을 만들었고. 그런데 일부 개발자들이 잘못된 방법으로 이 클래스를 사용하기기 시작했다. 이클립스, Jetbrain에서 코드 자동완성 기능을 이용하게 되는데 Containner 클래스에 정의된 메스드 뿐만 아니라 상위 클래스의 ArrayList 클래스에 등록된 메서드 목록을 함께 보여주어 의도와는 다르게 add 메서드를 사용하게 되어 오용의 여지를 준 Containner 클래스 작성자에 있는 것을 보여준다.

## 2. 조립을 이용한 재사용
객체 조립(composition)은 여러 객체를 묶어서 더 복잡한 기능을 제공하는 객체를 만들어내는 것이다. 객체 지향 언어에서 객체 조립은 보통 필드에서 다른 객체를 참조하는 방식으로 구현된다. 한 객체가 다른 객체를 조립해서 필드로 갖는다는 것은 다른 객체의 기능을 사용한다는 의미를 내포한다. 조립을 통한 재사용은 앞서 상속을 통한 재사용에서 발생했던 문제들을 해소해준다.


## 2.1 위임
위임(delegation)은 내가 할 일을 다른 객체에게 넘긴다는 의미를 담고 있으며, 보통 조립 방식을 이용해서 위임을 구현한다.
예를들을 이미지 편집 툴을 만들 경우 마우스 포인터의 위치가 특정 도형이 차지하는 영역에 포함되어 있는지 확인하는 기능이 필요할 것이다. 그런데, 도형과 관련된 Bounds 클래스가 이 기능을 이미 제공하고 있다면, 도형을 ㅛ현하는 Figure 클래스의 contains() 메서드는 Bounds 객체에게 포함 여부 확인 여부를 대신 확인ㅇ해 달라고 위임할 수 있다
``` java 
public abstract class Figure {
    private Bounds bounds = new Bounds();
    '''
    private void changeSize() {
        // 크기 변경 코드 위치
        bounds.set(x, y width, height);
    }
}
```
보통 위임은 조립과 마찬가지로 요청을 위임할 객체를 필드로 연결한다. 하지만, 꼭 필드로 정의해야 하는 것은 아니며 위임의 의도는 다른 객체에게 내가 할 일을 넘긴다는데 있으므로, 객체를 새로 생성해서 요청을 전달해도 위임이란 의미를 벗어나지 않는다.
객체 지향은 책임에 따라 객체들이 세분화되는 특징을 갖는다. 따라서 객체 지향적으로 구현을 하면 자연스럽게 많은 객체들이 만들어지고, 이 과정에서 조립과 우임을 통해 객체를 재사용하게 된다.

## 2.2 상속은 언제 사용하나?
상속을 사용할 때에는, 재사용이라는 관점이 아닌 기능의 확장이라는 관점에서 상속을 적용해야 한다. 또한 추가로 명확한 IS-A 관계가 성립되어야 하고, 이런 대표적인 예가 UI 위젯이다.

